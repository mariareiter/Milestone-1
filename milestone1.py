# -*- coding: utf-8 -*-
"""Updated Milestone1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1U0ENXGv1HOSXL-V0cxcwpSLazVhwzXaW
"""

!pip install Faker fastavro pandas

"""- **Passenger Requests and Cancellations**: For passenger requests and cancellations.
- **Driver Availability Updates**: For driver availability.

---
"""

!pip install fastavro
!pip install confluent-kafka
!pip install faker

from confluent_kafka import Producer
import random
import fastavro
import io
from datetime import datetime, timedelta
from faker import Faker
import time
from tqdm import tqdm

# Setup
fake = Faker()


# Azure Event Hub connection config
EVENT_HUB_NAMESPACE = "iesstsabbadbaa-grp-01-05.servicebus.windows.net:9093"
RIDE_TOPIC = "ride_requests_group5"
DRIVER_TOPIC = "driver_availability_group5"

rides_producer_config = {
    "bootstrap.servers": EVENT_HUB_NAMESPACE,
    "security.protocol": "SASL_SSL",
    "sasl.mechanisms": "PLAIN",
    "sasl.username": "$ConnectionString",
    "sasl.password": (
        "Endpoint=sb://iesstsabbadbaa-grp-01-05.servicebus.windows.net/;"
        "SharedAccessKeyName=rideproducer;"
        "SharedAccessKey=7+4lt5nK7tXY3rIE14VB7l7jlPKXL9UaC+AEhCXmpNM=;"
        "EntityPath=ride_requests_group5"
    )
}

"""

---

"""





import random
from faker import Faker
import fastavro
import datetime

from datetime import datetime, timedelta
from typing import Tuple, Dict, Any
import uuid

# Define a handful of “zones” with centroid coords for pickup/dropoff sampling
ZONES = {
    "Downtown": (40.7128, -74.0060),
    "Suburbs":  (40.7891, -73.1350),
    "Airport":  (40.6413, -73.7781),
}

def sample_zone_coordinates(zone: str) -> Tuple[float, float]:
    """
    Returns a latitude,longitude by sampling a small Gaussian around the zone centroid.
    """
    import random
    lat, lon = ZONES.get(zone, ZONES["Downtown"])
    return lat + random.gauss(0, 0.005), lon + random.gauss(0, 0.005)

def get_base_vehicle_price_range(vehicle_type: str) -> Tuple[int,int]:
    """
    Base price ranges by vehicle type; used before applying surge.
    """
    mapping = {
        "standard": (5, 20),
        "premium":  (15, 40),
        "shared":   (3, 15),
    }
    return mapping.get(vehicle_type, (5,20))

def adjust_price_for_demand(base_price: float, demand_level: str) -> float:
    """
    Multiplier by demand: low (1.0–1.1), medium (1.2–1.5), high (1.5–2.0).
    """
    import random
    multipliers = {
        "low":    random.uniform(1.0, 1.1),
        "medium": random.uniform(1.2, 1.5),
        "high":   random.uniform(1.5, 2.0),
    }
    return round(base_price * multipliers[demand_level], 2)

"""## Passenger Requests and Cancellations Schema:"""

passenger_request_schema = {
    "type": "record",
    "name": "PassengerRequest",
    "fields": [
        {"name": "request_id", "type": "string"},
        {"name": "passenger_id", "type": "string"},
        {"name": "passenger_name", "type": "string"},
        {"name": "pickup_location", "type": "string"},
        {"name": "dropoff_location", "type": "string"},
        {"name": "request_time", "type": "string"},
        {
            "name": "status",
            "type": {
                "type": "enum",
                "name": "Status",
                "symbols": ["requested", "accepted", "canceled", "completed"]
            }
        },
        {
            "name": "cancellation_time",
            "type": ["null", "string"],  # Correct use of null as a type in Python
            "default": None  # Use None (Python's null equivalent)
        },
        {"name": "ride_duration", "type": "int", "default": 30},
        {"name": "vehicle_type", "type": "string", "default": "standard"},
        {"name": "estimated_eta", "type": "string", "default": "20 minutes"},
        {
            "name": "demand_level",
            "type": {
                "type": "enum",
                "name": "DemandLevel",
                "symbols": ["High", "Medium", "Low"]
            },
            "default": "Medium"
        },
        {"name": "price", "type": "float"},
        {"name": "driver_rating", "type": "float"},
        {"name": "passenger_rating", "type": "float"},
        {
            "name": "favorite_location",
            "type": ["null", "string"],  # Correct use of null as a type in Python
            "default": None  # Use None for nullable fields in Python
        },
        {
            "name": "is_wheelchair_accessible",
            "type": "boolean",
            "default": False  # Use False (Python's boolean equivalent)
        },
        {
            "name": "scheduled_time",
            "type": ["null", "string"],
            "default": None  # Use None for nullable fields
        },
        {
            "name": "multiple_stops",
            "type": ["null", {"type": "array", "items": "string"}],
            "default": None
        },
        {
            "name": "donation_amount",
            "type": ["null", "float"],
            "default": None  # Use None for nullable fields
        },
        {"name": "vehicle_license_plate", "type": "string"}
    ]
}

"""- **request_id**: A unique ID for the request.
- **passenger_id**: A unique ID for the passenger.
- **passenger_name**
- **pickup_location**: Where the passenger is requesting the ride from.
- **dropoff_location**: The destination of the ride.
- **request_time**: The time when the passenger requests the ride.
- **status**: The status of the ride (requested, accepted, canceled, or completed).
- **cancellation_time**: If the request is canceled, this field records the cancellation time.
- **ride_duration**: The duration of the ride in minutes. The default is set to 30 minutes, but this can be updated based on the ride specifics.
- **vehicle_type**: The type of vehicle requested by the passenger
- **estimated_eta**: estimated time of arrival for drivers  based on current traffic conditions and proximity. The default is set to 20 minutes
- **demand_level**: The level of demand for rides in the area. This helps adjust the pricing or availability of vehicles based on whether it's high, medium, or low demand.
- **price**: The price of the ride based on the vehicle type, distance, and demand
- **driver_rating**: The rating given to the driver, which could be between 3.5 and 5 stars. A low rating (below 3.5) could cause the ride to be canceled.
- **passenger_rating**: The rating given by the driver to the passenger. It typically ranges from 4 to 5 stars, as passengers are generally rated positively.
- **favorite_location**: A location the passenger frequently uses (e.g., "Home", "Work"). This field is optional, and if not set, it defaults to None.
- **is_wheelchair_accessible**: A flag indicating whether the passenger requested a wheelchair-accessible vehicle. This is a boolean value (True or False).
- **scheduled_time**: The time at which the passenger wants to schedule the ride in advance. If not scheduled, it defaults to None. This allows passengers to set a pickup time in the future.
- **multiple_stops**: An array of strings representing multiple stops during the ride. This allows for additional destinations to be added along the way.
- **donation_amount**: The optional donation amount the passenger can choose to add to the fare, typically in increments of 5, 10, or 15. This field is nullable (None by default), allowing passengers who do not wish to donate to leave it empty.
- **vehicle_license_plate**

## Driver Availability Updates Schema
"""

driver_availability_schema = {
    "type": "record",
    "name": "DriverAvailability",
    "fields": [
        {"name": "driver_id", "type": "string"},
        {"name": "driver_name", "type": "string"},
        {
            "name": "status",
            "type": {
                "type": "enum",
                "name": "Status",
                "symbols": ["available", "unavailable"]
            }
        },
        {"name": "update_time", "type": "string"},
        {"name": "driver_rating", "type": "float"},
        {
            "name": "is_wheelchair_accessible",
            "type": "boolean",
            "default": False  # Flag for wheelchair accessible vehicles
        },
        {"name": "vehicle_license_plate", "type": "string"}
    ]
}

"""- **driver_id**: A unique ID for the driver.
- **driver_name**
- **status**: The status of the driver (either "available" or "unavailable").
- **update_time**: The time when the driver’s availability status is updated.
- **driver_rating**: The rating given to the driver by passengers. This typically ranges from 1 to 5, with a higher rating indicating better service.
- **is_wheelchair_accessible**: A flag indicating whether the driver’s vehicle is wheelchair accessible. The default value is set to False, meaning the vehicle is not accessible unless explicitly marked as True.
- **vehicle_license_plate**

## Generate synthetic data
"""

import random
from faker import Faker
import datetime
import fastavro
import json

# Initialize Faker to generate random data
fake = Faker()

def generate_realistic_time(base: datetime = None, variance_minutes: int = 30) -> datetime:
    if base is None:
        base = datetime.datetime.utcnow()
    offset = random.randint(-variance_minutes, variance_minutes)
    return base + timedelta(minutes=offset)

# Define price range based on vehicle type
def get_base_vehicle_price_range(vehicle_type):
    price_range_map = {
        "Black/Executive": (100, 150),  # $100 to $150
        "Van XL": (90, 140),  # $90 to $140
        "Van": (80, 120),  # $80 to $120
        "Priority": (70, 110),  # $70 to $110
        "Baby": (60, 100),  # $60 to $100
        "Kids": (50, 90),  # $50 to $90
        "Comfort": (40, 80),  # $40 to $80
        "Pet": (35, 70),  # $35 to $70
        "Electric": (30, 60),  # $30 to $60
        "Taxi": (20, 30),  # $20 to $30
        "Share": (10, 20),  # $10 to $20
        "Wheelchair": (60, 100)  # Wheelchair accessible vehicle price range
    }
    return price_range_map.get(vehicle_type, (20, 30))  # Default to Taxi price range if not found

# Function to simulate demand and adjust the price dynamically within the range
def adjust_price_for_demand(base_min, base_max):
    # Simulate a demand factor (between 1.0 and 2.0)
    demand_factor = random.uniform(1.0, 2.0)  # This simulates the demand multiplier

    # Categorize demand level
    if demand_factor >= 1.5:
        demand_level = "High"
    elif demand_factor >= 1.2:
        demand_level = "Medium"
    else:
        demand_level = "Low"

    adjusted_price = random.uniform(base_min, base_max) * demand_factor  # Adjust the price based on demand
    return round(adjusted_price, 2), demand_level  # Round to two decimal places for price

# Function to generate a driver rating (between 3.5 and 5 for most drivers, below 3.5 is rare)
def generate_driver_rating():
    rating = random.uniform(3.5, 5)  # Default range for drivers is 3.5 to 5
    if random.random() < 0.1:  # 10% chance to have a rating below 3.5
        rating = random.uniform(1, 3.5)  # Ratings below 3.5 are rare
    return round(rating, 1)

# Function to generate a passenger rating (between 4 and 5 stars)
def generate_passenger_rating():
    return round(random.uniform(4, 5), 1)  # Random rating between 4 and 5 stars

# Function to generate a passenger request event with multiple stops set to None or empty list
def generate_passenger_request(demand_level: str = "medium") -> Dict[str, Any]:
    # IDs & basic info
    request_id = str(uuid.uuid4())
    passenger_id = str(uuid.uuid4())
    passenger_name = fake.name()

    # Zones & coords
    pickup_zone = random.choice(list(ZONES))
    dropoff_zone = random.choice(list(ZONES))
    pickup_lat, pickup_lon   = sample_zone_coordinates(pickup_zone)
    dropoff_lat, dropoff_lon = sample_zone_coordinates(dropoff_zone)

    # Times
    request_time = generate_realistic_time()
    eta = random.randint(5, 30)

    # Status & possible cancellation
    status = "requested"
    cancellation_time = None
    if eta > 20 and random.random() < 0.4:
        status = "canceled"
        cancellation_time = int(generate_realistic_time(request_time).timestamp() * 1000)

    # Pricing
    vehicle_type = random.choice(["standard","premium","shared"])
    base_min, base_max = get_base_vehicle_price_range(vehicle_type)  # Get price range for the vehicle type
    price, _ = adjust_price_for_demand(base_min, base_max)  # Pass min/max to adjust_price_for_demand

    return {
        "request_id": request_id,
        "passenger_id": passenger_id,
        "passenger_name": passenger_name,
        "pickup_lat": pickup_lat,
        "pickup_lon": pickup_lon,
        "dropoff_lat": dropoff_lat,
        "dropoff_lon": dropoff_lon,
        "request_time": int(request_time.timestamp() * 1000),
        "status": status,
        "cancellation_time": cancellation_time,
        "ride_duration": None,
        "vehicle_type": vehicle_type,
        "estimated_eta": eta,
        "demand_level": demand_level,
        "price": price,
        "driver_rating": None,
        "passenger_rating": None,
        "favorite_location": random.choice([None, "Home", "Work"]),
        "is_wheelchair_accessible": random.random() < 0.1,
        "scheduled_time": None,
        "multiple_stops": [],
        "donation_amount": None,
        "vehicle_license_plate": fake.license_plate(),
    }


# Function to generate a driver availability event
def generate_driver_availability() -> Dict[str, Any]:
    driver_id = str(uuid.uuid4())
    driver_name = fake.name()
    status = random.choices(
        ["available","on_trip","offline"], weights=[0.6,0.3,0.1]
    )[0]
    update_time = generate_realistic_time()
    driver_rating = round(random.uniform(3.5, 5.0), 2)

    return {
        "driver_id": driver_id,
        "driver_name": driver_name,
        "status": status,
        "update_time": int(update_time.timestamp() * 1000),
        "driver_rating": driver_rating,
        "is_wheelchair_accessible": False,
        "vehicle_license_plate": fake.license_plate(),
    }

# Generate configurable number of events
def generate_events(passenger_count, driver_count):
    passenger_events = [generate_passenger_request() for _ in range(passenger_count)] # Remove extra arguments, use _ for unused loop variable
    driver_availability_events = [generate_driver_availability() for _ in range(driver_count)]
    return passenger_events, driver_availability_events

# Example usage: Generate 200 passenger requests and 100 driver availability events
passenger_events, driver_availability_events = generate_events(200, 100)

# Serialize the data to JSON format
with open('passenger_requests.json', 'w') as json_file:
    json.dump(passenger_events, json_file, indent=4)

with open('driver_availability.json', 'w') as json_file:
    json.dump(driver_availability_events, json_file, indent=4)

passenger_request_schema = {
    "namespace": "ride_hailing",
    "type": "record",
    "name": "PassengerRequest",
    "fields": [
        { "name": "request_id",               "type": "string" },
        { "name": "passenger_id",             "type": "string" },
        { "name": "passenger_name",           "type": "string" },
        { "name": "pickup_lat",               "type": "double" },
        { "name": "pickup_lon",               "type": "double" },
        { "name": "dropoff_lat",              "type": "double" },
        { "name": "dropoff_lon",              "type": "double" },
        {
          "name": "request_time",
          "type": { "type": "long", "logicalType": "timestamp-millis" }
        },
        { "name": "status",                   "type": "string" },
        {
          "name": "cancellation_time",
          "type": [
            "null",
            { "type": "long", "logicalType": "timestamp-millis" }
          ],
          "default": None
        },
        { "name": "ride_duration",            "type": ["null", "int"],   "default": None },
        { "name": "vehicle_type",             "type": "string" },
        { "name": "estimated_eta",            "type": "int" },
        { "name": "demand_level",             "type": "string" },
        { "name": "price",                    "type": "double" },
        { "name": "driver_rating",            "type": ["null", "double"], "default": None },
        { "name": "passenger_rating",         "type": ["null", "double"], "default": None },
        { "name": "favorite_location",        "type": ["null", "string"], "default": None },
        { "name": "is_wheelchair_accessible", "type": "boolean" },
        {
          "name": "scheduled_time",
          "type": [
            "null",
            { "type": "long", "logicalType": "timestamp-millis" }
          ],
          "default": None
        },
        {
          "name": "multiple_stops",
          "type": { "type": "array", "items": "string" }
        },
        { "name": "donation_amount",          "type": ["null", "double"], "default": None },
        { "name": "vehicle_license_plate",    "type": "string" },
    ]
}

driver_availability_schema = {
    "namespace": "ride_hailing",
    "type": "record",
    "name": "DriverAvailability",
    "fields": [
        { "name": "driver_id",               "type": "string" },
        { "name": "driver_name",             "type": "string" },
        { "name": "status",                  "type": "string" },
        {
          "name": "update_time",
          "type": { "type": "long", "logicalType": "timestamp-millis" }
        },
        { "name": "driver_rating",           "type": "double" },
        { "name": "is_wheelchair_accessible","type": "boolean" },
        { "name": "vehicle_license_plate",   "type": "string" },
    ]
}

import json
import fastavro

# How many events to simulate
NUM_EVENTS = 1000

# Generate lists using your new generators
passenger_events = [
    generate_passenger_request(demand_level="medium")
    for _ in range(NUM_EVENTS)
]
driver_events = [
    generate_driver_availability()
    for _ in range(NUM_EVENTS)
]

# 1) Write out JSON (newline‑delimited for easy streaming)
with open("passenger_requests.json", "w") as jf:
    for evt in passenger_events:
        jf.write(json.dumps(evt) + "\n")

with open("driver_availability.json", "w") as jf:
    for evt in driver_events:
        jf.write(json.dumps(evt) + "\n")

# 2) Write out AVRO
with open("passenger_requests.avro", "wb") as af:
    fastavro.writer(af, passenger_request_schema, passenger_events)

with open("driver_availability.avro", "wb") as af:
    fastavro.writer(af, driver_availability_schema, driver_events)

print(f"Wrote {NUM_EVENTS} passenger + {NUM_EVENTS} driver events in JSON & AVRO.")

"""### Output Sample Data for Verification"""

import json
import pandas as pd
import fastavro
from IPython.display import display

# 1) JSON (newline‑delimited)
with open('passenger_requests.json', 'r') as f:
    passenger_json = [json.loads(line) for _, line in zip(range(5), f)]
passenger_json_df = pd.DataFrame(passenger_json)
print("First 5 Passenger Requests (JSON):")
display(passenger_json_df)

with open('driver_availability.json', 'r') as f:
    driver_json = [json.loads(line) for _, line in zip(range(5), f)]
driver_json_df = pd.DataFrame(driver_json)
print("\nFirst 5 Driver Availability Entries (JSON):")
display(driver_json_df)

# 2) AVRO
with open('passenger_requests.avro', 'rb') as f:
    reader = fastavro.reader(f)
    passenger_avro = [r for i, r in enumerate(reader) if i < 5]
passenger_avro_df = pd.DataFrame(passenger_avro)
print("\nFirst 5 Passenger Requests (AVRO):")
display(passenger_avro_df)

with open('driver_availability.avro', 'rb') as f:
    reader = fastavro.reader(f)
    driver_avro = [r for i, r in enumerate(reader) if i < 5]
driver_avro_df = pd.DataFrame(driver_avro)
print("\nFirst 5 Driver Availability Entries (AVRO):")
display(driver_avro_df)

# -*- coding: utf-8 -*-
"""FINAL_SIMULATION.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/17vtqC02ig90j7FycvwU_wE5Sq4wYjl6t
"""

# prompt: pip install fastavro

!pip install fastavro
!pip install confluent-kafka
!pip install faker

from confluent_kafka import Producer
import random
import fastavro
import io
from datetime import datetime, timedelta
from faker import Faker
import time
from tqdm import tqdm

# Setup
fake = Faker()

# Azure Event Hub connection config
EVENT_HUB_NAMESPACE = "iesstsabbadbaa-grp-01-05.servicebus.windows.net:9093"
RIDE_TOPIC = "ride_requests_group5"
DRIVER_TOPIC = "driver_availability_group5"

rides_producer_config = {
    "bootstrap.servers": EVENT_HUB_NAMESPACE,
    "security.protocol": "SASL_SSL",
    "sasl.mechanisms": "PLAIN",
    "sasl.username": "$ConnectionString",
    "sasl.password": (
        "Endpoint=sb://iesstsabbadbaa-grp-01-05.servicebus.windows.net/;"
        "SharedAccessKeyName=rideproducer;"
        "SharedAccessKey=7+4lt5nK7tXY3rIE14VB7l7jlPKXL9UaC+AEhCXmpNM=;"
        "EntityPath=ride_requests_group5"
    )
}

rides_producer = Producer(rides_producer_config)

drivers_producer_config = {
    "bootstrap.servers": EVENT_HUB_NAMESPACE,
    "security.protocol": "SASL_SSL",
    "sasl.mechanisms": "PLAIN",
    "sasl.username": "$ConnectionString",
    "sasl.password": (
        "Endpoint=sb://iesstsabbadbaa-grp-01-05.servicebus.windows.net/;"
        "SharedAccessKeyName=driverproducer;"
        "SharedAccessKey=Sh4m05EQ7ggASqZjMQ6vWBuoX7YNKmpMX+AEhJgoMFI=;"
        "EntityPath=driver_availability_group5"
    )
}

drivers_producer = Producer(drivers_producer_config)

# Enhanced configuration
CONFIG = {
    "num_rides": 15000,
    "num_drivers": 5000,
    "simulate_surge": True,
    "simulate_traffic": True,
    "inject_short_trips": True,
    "inject_fake_cancellations": True,
    "inject_surge_anomalies": True
}

# Extended NY Streets list
NY_STREETS = [
    # Manhattan Classics
    "5th Avenue", "Broadway", "Wall Street", "Madison Avenue", "Lexington Avenue",
    "Park Avenue", "Houston Street", "Delancey Street", "Canal Street", "Bowery",
    "West 42nd Street", "East 14th Street", "Christopher Street", "Varick Street", "Bleecker Street",
    "St. Mark's Place", "Seventh Avenue", "Ninth Avenue", "Amsterdam Avenue", "Columbus Avenue",
    # Brooklyn Legends
    "Flatbush Avenue", "Atlantic Avenue", "Bedford Avenue", "Fulton Street", "Eastern Parkway",
    "Court Street", "Kings Highway", "Ocean Parkway", "Dekalb Avenue", "Church Avenue",
    # Queens Reps
    "Queens Boulevard", "Jamaica Avenue", "Northern Boulevard", "Steinway Street", "Astoria Boulevard",
    "Roosevelt Avenue", "Liberty Avenue", "Rockaway Boulevard", "Hillside Avenue", "Main Street",
    # Bronx Flavor
    "Grand Concourse", "Fordham Road", "Jerome Avenue", "White Plains Road", "Tremont Avenue",
    "Arthur Avenue", "Webster Avenue", "Bronx River Parkway", "Sedgwick Avenue", "Kingsbridge Road",
    # Staten Island Love
    "Hylan Boulevard", "Richmond Avenue", "Victory Boulevard", "Bay Street", "Forest Avenue",
    # Bonus Flavor (NYC Icons & Spots)
    "Times Square", "Union Square", "Washington Square North", "Battery Place", "Tribeca West Street",
    "Chelsea Market Way", "Central Park West", "Lincoln Center Drive", "Metropolitan Avenue"
]

# Add to your constants section
LOCATION_COORDINATES = {
    # Manhattan
    "5th Avenue": (40.7750, -73.9654), "Broadway": (40.7590, -73.9845), "Wall Street": (40.7075, -74.0113),
    "Madison Avenue": (40.7637, -73.9720), "Lexington Avenue": (40.7570, -73.9705), "Park Avenue": (40.7517, -73.9763),
    "Houston Street": (40.7250, -73.9950), "Delancey Street": (40.7193, -73.9887), "Canal Street": (40.7181, -74.0006),
    "Bowery": (40.7203, -73.9939), "West 42nd Street": (40.7561, -73.9903), "East 14th Street": (40.7336, -73.9835),
    "Christopher Street": (40.7321, -74.0030), "Varick Street": (40.7272, -74.0064), "Bleecker Street": (40.7254, -73.9949),
    "St. Mark's Place": (40.7292, -73.9846), "Seventh Avenue": (40.7395, -74.0026), "Ninth Avenue": (40.7440, -74.0027),
    "Amsterdam Avenue": (40.7966, -73.9707), "Columbus Avenue": (40.7850, -73.9740),
    # Brooklyn
    "Flatbush Avenue": (40.6527, -73.9628), "Atlantic Avenue": (40.6832, -73.9765), "Bedford Avenue": (40.7081, -73.9571),
    "Fulton Street": (40.6885, -73.9802), "Eastern Parkway": (40.6700, -73.9511), "Court Street": (40.6914, -73.9918),
    "Kings Highway": (40.6057, -73.9609), "Ocean Parkway": (40.6126, -73.9656), "Dekalb Avenue": (40.6894, -73.9740),
    "Church Avenue": (40.6506, -73.9606),
    # Queens
    "Queens Boulevard": (40.7359, -73.8690), "Jamaica Avenue": (40.7027, -73.7896), "Northern Boulevard": (40.7618, -73.8970),
    "Steinway Street": (40.7580, -73.9189), "Astoria Boulevard": (40.7694, -73.9225), "Roosevelt Avenue": (40.7489, -73.8782),
    "Liberty Avenue": (40.6852, -73.8290), "Rockaway Boulevard": (40.6756, -73.8195), "Hillside Avenue": (40.7117, -73.7699),
    "Main Street": (40.7595, -73.8292),
    # Bronx
    "Grand Concourse": (40.8270, -73.9254), "Fordham Road": (40.8613, -73.8902), "Jerome Avenue": (40.8505, -73.9104),
    "White Plains Road": (40.8416, -73.8661), "Tremont Avenue": (40.8473, -73.8962), "Arthur Avenue": (40.8550, -73.8881),
    "Webster Avenue": (40.8620, -73.8964), "Bronx River Parkway": (40.8417, -73.8723), "Sedgwick Avenue": (40.8618, -73.9123),
    "Kingsbridge Road": (40.8675, -73.8978),
    # Staten Island
    "Hylan Boulevard": (40.5595, -74.1201), "Richmond Avenue": (40.5824, -74.1654), "Victory Boulevard": (40.6248, -74.1483),
    "Bay Street": (40.6383, -74.0756), "Forest Avenue": (40.6270, -74.1236),
    # NYC Icons
    "Times Square": (40.7580, -73.9855), "Union Square": (40.7359, -73.9911), "Washington Square North": (40.7313, -73.9970),
    "Battery Place": (40.7043, -74.0170), "Tribeca West Street": (40.7207, -74.0106), "Chelsea Market Way": (40.7423, -74.0060),
    "Central Park West": (40.7812, -73.9665), "Lincoln Center Drive": (40.7725, -73.9847), "Metropolitan Avenue": (40.7112, -73.9442)
}

# Utility function to retrieve lat/lng
def get_location_coordinates(location_name):
    return LOCATION_COORDINATES.get(location_name, (
        round(random.uniform(40.6000, 40.8800), 6),
        round(random.uniform(-74.0500, -73.8500), 6)
    ))

# Constants for simulation
PAYMENT_METHODS = ["credit_card", "cash", "mobile_payment", "voucher", "Paypal"]
WEATHER_CONDITIONS = ["sunny", "cloudy", "rainy", "snowy", "foggy"]
LOYALTY_TIERS = ["Bronze", "Silver", "Gold", "Platinum"]

# Car categories and brands
SERVICE_TYPES = ["Share", "Standard", "Green", "Comfort", "Black", "Van"]
SERVICE_TIME_MODES = ["Wait and Save", "Programmed Ride", "Just Ride"]

BLACK_CAR_BRANDS = ["Tesla", "Porsche", "Land Rover", "Mercedes-Benz", "BMW", "Audi", "Jaguar", "Cadillac"]
COMFORT_BRANDS = ["Volvo", "LEXUS", "Buick", "Acura", "Chrysler"]
GREEN_CAR_BRANDS = ["Tesla", "Nissan", "Hyundai", "Kia", "Toyota", "Chevrolet", "Volkswagen"]
STANDARD_CAR_BRANDS = ["Toyota", "Ford", "Honda", "Hyundai", "Chevrolet", "Kia", "Nissan", "Mazda", "Subaru", "Jeep"]
VAN_CAR_BRANDS = ["Mercedes-Benz", "Toyota", "Volkswagen", "Ford", "Chrysler", "Kia"]
SHARE_CAR_BRANDS = ["Fiat", "Mini", "Nissan", "Hyundai", "Chevrolet", "Ford", "Toyota"]
CATEGORY_TO_BRANDS = {
    "Black": BLACK_CAR_BRANDS,
    "Comfort": COMFORT_BRANDS,
    "Green": GREEN_CAR_BRANDS,
    "Standard": STANDARD_CAR_BRANDS,
    "Van": VAN_CAR_BRANDS,
    "Share": SHARE_CAR_BRANDS
}

CANCELLATION_REASONS = ["No driver available", "User cancelled", "Driver cancelled", "Pricing issue", "Long waiting time"]
PROMO_CODES = ["SAVE10", "RIDEFREE", None, None, None, None]  # More likely to have no promo code
LANGUAGES = ["English", "Spanish", "French", "Mandarin", "Arabic", "Russian", "Italian", "Japanese"]

# Updated Avro schemas with expanded fields

# Update the ride request schema
ride_request_avro_schema = {
    "type": "record",
    "name": "RideRequest",
    "fields": [
        {"name": "user_id", "type": "string"},
        {"name": "user_name", "type": "string"},
        {"name": "pickup_location", "type": "string"},
        {"name": "pickup_lat", "type": "double"},
        {"name": "pickup_lng", "type": "double"},
        {"name": "destination", "type": "string"},
        {"name": "destination_lat", "type": "double"},
        {"name": "destination_lng", "type": "double"},
        {"name": "timestamp", "type": "string"},
        {"name": "pickup_time", "type": ["null", "string"], "default": None},
        {"name": "dropoff_time", "type": ["null", "string"], "default": None},
        {"name": "status", "type": {"type": "enum", "name": "Status", "symbols": ["requested", "cancelled", "accepted", "ongoing", "completed"]}},
        {"name": "price", "type": ["null", "double"], "default": 0.0},
        {"name": "surge", "type": "boolean"},
        {"name": "traffic", "type": "string"},
        {"name": "payment_mode", "type": "string"},
        {"name": "weather", "type": "string"},
        {"name": "vehicle_type", "type": ["null", "string"], "default": None},
        {"name": "vehicle_brand", "type": ["null", "string"], "default": None},
        {"name": "driver_id", "type": ["null", "string"], "default": None},
        {"name": "distance_km", "type": ["null", "double"], "default": 0.0},
        {"name": "estimated_duration_min", "type": ["null", "double"], "default": 0.0},
        {"name": "cancellation_reason", "type": ["null", "string"], "default": None},
        {"name": "promo_code", "type": ["null", "string"], "default": None},
        {"name": "is_premium_user", "type": "boolean"},
        {"name": "estimated_driver_arrival_min", "type": ["null", "double"], "default": 0.0},
        {"name": "car_category", "type": "string"},
        {"name": "time_programmed", "type": ["null", "string"], "default": None},
        {"name": "time_of_service", "type": "string"},
        {"name": "final_price", "type": ["null", "double"], "default": 0.0}
    ]
}

# Update the driver availability schema
driver_availability_avro_schema = {
    "type": "record",
    "name": "DriverAvailability",
    "fields": [
        {"name": "driver_id", "type": "string"},
        {"name": "driver_name", "type": "string"},
        {"name": "location", "type": "string"},
        {"name": "latitude", "type": "double"},
        {"name": "longitude", "type": "double"},
        {"name": "status", "type": {"type": "enum", "name": "DriverStatus", "symbols": ["available", "busy"]}},
        {"name": "timestamp", "type": "string"},
        {"name": "license_plate", "type": "string"},
        {"name": "vehicle_type", "type": "string"},
        {"name": "vehicle_brand", "type": "string"},
        {"name": "rating", "type": "double"},
        {"name": "loyalty_tier", "type": "string"},
        {"name": "years_of_experience", "type": "int"},
        {"name": "is_verified", "type": "boolean"},
        {"name": "languages_spoken", "type": {"type": "array", "items": "string"}}
    ]
}


# Enhanced utility functions
def generate_time_based_timestamp():
    """Generate realistic timestamp based on time-of-day blocks"""
    time_blocks = [
        (7, 9),    # morning rush
        (12, 14),  # lunch
        (17, 19),  # evening rush
        (0, 2)     # late night
    ]
    hour_range = random.choice(time_blocks)
    hour = random.randint(*hour_range)
    dt = datetime.utcnow().replace(hour=hour, minute=random.randint(0, 59), second=0, microsecond=0)
    return dt.isoformat()

def get_surge_price(base_price, location, timestamp):
    """Simulate surge pricing based on time and location with optional anomalies"""
    hour = int(timestamp[11:13])
    is_peak = 7 <= hour <= 9 or 17 <= hour <= 20
    is_hot_zone = any(keyword in location for keyword in ["Avenue", "Broadway", "Boulevard", "Park", "Times Square"])
    should_surge = is_peak and is_hot_zone and random.random() < 0.7

    # Inject anomalous surge pricing occasionally
    if CONFIG["inject_surge_anomalies"] and random.random() < 0.02:
        # Either extremely high surge or surge at unusual time/place
        if random.random() < 0.5:
            # Extremely high surge
            return round(base_price * random.uniform(2.5, 4.0), 2), True
        else:
            # Surge at unusual time/place (off-peak or unpopular area)
            if not should_surge:
                return round(base_price * random.uniform(1.5, 2.0), 2), True

    if CONFIG["simulate_surge"] and should_surge:
        return round(base_price * random.uniform(1.5, 2.0), 2), True

    return base_price, False

def get_traffic_condition(location, timestamp):
    """Simulate traffic condition based on location and time"""
    hour = int(timestamp[11:13])
    if CONFIG["simulate_traffic"] and (location in NY_STREETS) and (hour in list(range(7, 10)) + list(range(17, 20))):
        return random.choice(["heavy", "moderate"])
    return "light"

def generate_license_plate():
    """Generate a realistic license plate"""
    return f"{''.join(random.choices('ABCDEFGHIJKLMNOPQRSTUVWXYZ', k=3))}-{''.join(random.choices('0123456789', k=4))}"

def to_avro_binary(record, schema):
    """Serialize record to Avro binary format"""
    buffer = io.BytesIO()
    fastavro.schemaless_writer(buffer, schema, record)
    return buffer.getvalue()

# Enhanced simulation functions
def generate_ride():
    """Generate a realistic ride request with enhanced details including geographic coordinates"""
    # Determine ride status
    # Add increased cancellation probability if configured
    if CONFIG["inject_fake_cancellations"] and random.random() < 0.15:
        status = "cancelled"
    else:
        status = random.choice(["requested", "cancelled", "accepted", "ongoing", "completed"])

    # Generate base timestamp and location
    ts = generate_time_based_timestamp()
    pickup = random.choice(NY_STREETS)
    destination = random.choice([s for s in NY_STREETS if s != pickup])

    # Get geographic coordinates
    pickup_lat, pickup_lng = get_location_coordinates(pickup)
    destination_lat, destination_lng = get_location_coordinates(destination)

    # Setup service type and time mode
    car_category = random.choice(SERVICE_TYPES)
    time_of_service = random.choices(
        SERVICE_TIME_MODES,
        weights=[0.3, 0.05, 0.65]  # 30% Wait and Save, 10% Programmed Ride, 60% Just Ride
    )[0]


    # Select vehicle brand based on category
    vehicle_brand = random.choice(CATEGORY_TO_BRANDS.get(car_category, STANDARD_CAR_BRANDS))

    # Calculate trip distance - with option for short trips if configured
    if CONFIG["inject_short_trips"] and random.random() < 0.2:
        distance_km = round(random.uniform(0.5, 2.5), 2)  # Very short trips
    else:
        distance_km = round(random.uniform(1.0, 20.0), 2)

    # Traffic condition
    traffic = get_traffic_condition(pickup, ts)

    # Pricing logic
    # Base fare calculations with modifiers
    base_rate_per_km = 2.0
    traffic_multiplier = {"light": 1.0, "moderate": 1.2, "heavy": 1.5}
    time_of_service_multiplier = {"Wait and Save": 0.85, "Just Ride": 1.0, "Programmed Ride": 1.15}
    service_price_multiplier = {"Share": 0.8, "Standard": 1.0, "Green": 1.1, "Comfort": 1.25, "Black": 1.5, "Van": 1.3}

    # Calculate base price
    base_price = round(
        distance_km * base_rate_per_km *
        traffic_multiplier.get(traffic, 1.0) *
        service_price_multiplier.get(car_category, 1.0) *
        time_of_service_multiplier.get(time_of_service, 1.0),
        2
    )


    # Time-related fields
    pickup_time = None
    dropoff_time = None
    time_programmed = None
    estimated_driver_arrival_min = None

    # Handle timing for different statuses
    if status in ["accepted", "ongoing", "completed"]:
        pickup_dt = datetime.fromisoformat(ts) + timedelta(minutes=random.randint(2, 10))
        estimated_driver_arrival_min = round((pickup_dt - datetime.fromisoformat(ts)).total_seconds() / 60, 1)

        # Determine waiting time based on time_of_service
        if time_of_service == "Wait and Save":
            wait_minutes = random.randint(10, 20)
        elif time_of_service == "Just Ride":
            wait_minutes = random.randint(2, 6)
        elif time_of_service == "Programmed Ride":
            wait_minutes = random.randint(60, 1440)  # 1 to 24 hours in minutes
        else:
            wait_minutes = random.randint(2, 10)  # fallback

        pickup_dt = datetime.fromisoformat(ts) + timedelta(minutes=wait_minutes)
        estimated_driver_arrival_min = wait_minutes

        if time_of_service == "Programmed Ride":
            pickup_time = pickup_dt.isoformat()
            time_programmed = pickup_time
        else:
            pickup_time = pickup_dt.isoformat()


        # Calculate dropoff time based on distance and traffic
        minutes_per_km = {
            "light": 2.0,
            "moderate": 3.0,
            "heavy": 4.5
        }
        trip_minutes = max(5, round(distance_km * minutes_per_km.get(traffic, 2.5)))
        dropoff_dt = pickup_dt + timedelta(minutes=trip_minutes)
        dropoff_time = dropoff_dt.isoformat()

    elif time_of_service == "Programmed Ride":
        # Handle programmed rides even if not yet accepted
        time_programmed = (datetime.fromisoformat(ts) + timedelta(hours=random.randint(1, 24))).isoformat()

    # Apply surge pricing
    price, surge = get_surge_price(base_price, pickup, ts)

    # Apply "Wait and Save" discount first
    if time_of_service == "Wait and Save":
        wait_discount = round(price * 0.05, 2)
    else:
        wait_discount = 0.0

    price_after_wait_discount = round(price - wait_discount, 2)

    # Apply promo code on top of "Wait and Save"
    promo_code = random.choice(PROMO_CODES)
    if promo_code == "SAVE10":
        promo_discount = round(price_after_wait_discount * 0.10, 2)
    elif promo_code == "RIDEFREE":
        promo_discount = round(price_after_wait_discount * 0.25, 2)
    else:
        promo_discount = 0.0

    final_price = round(price_after_wait_discount - promo_discount, 2)

    return {
        "user_id": str(fake.uuid4()),
        "user_name": fake.name(),
        "pickup_location": pickup,
        "pickup_lat": pickup_lat,
        "pickup_lng": pickup_lng,
        "destination": destination,
        "destination_lat": destination_lat,
        "destination_lng": destination_lng,
        "timestamp": ts,
        "pickup_time": pickup_time,
        "dropoff_time": dropoff_time,
        "status": status,
        "price": price,
        "surge": surge,
        "traffic": traffic,
        "payment_mode": random.choice(PAYMENT_METHODS),
        "weather": random.choice(WEATHER_CONDITIONS),
        "vehicle_type": car_category,
        "vehicle_brand": vehicle_brand,
        "driver_id": str(fake.uuid4()) if status != "requested" else None,
        "distance_km": distance_km,
        "estimated_duration_min": (
            round((datetime.fromisoformat(dropoff_time) - datetime.fromisoformat(pickup_time)).total_seconds() / 60, 1)
            if pickup_time and dropoff_time else None
        ),
        "cancellation_reason": random.choice(CANCELLATION_REASONS) if status == "cancelled" else None,
        "promo_code": promo_code,
        "is_premium_user": random.choice([True, False]),
        "estimated_driver_arrival_min": estimated_driver_arrival_min,
        "car_category": car_category,
        "time_programmed": time_programmed,
        "time_of_service": time_of_service,
        "final_price": final_price
    }

def generate_driver():
    vehicle_category = random.choice(SERVICE_TYPES)
    vehicle_brand = random.choice(CATEGORY_TO_BRANDS.get(vehicle_category, STANDARD_CAR_BRANDS))

    location = random.choice(NY_STREETS)
    latitude, longitude = get_location_coordinates(location)

    return {
        "driver_id": str(fake.uuid4()),
        "driver_name": fake.name(),
        "location": location,
        "latitude": latitude,
        "longitude": longitude,
        "status": random.choice(["available", "busy"]),
        "timestamp": datetime.utcnow().isoformat(),
        "license_plate": generate_license_plate(),
        "vehicle_type": vehicle_category,
        "vehicle_brand": vehicle_brand,
        "rating": round(random.uniform(3.0, 5.0), 2),
        "loyalty_tier": random.choice(LOYALTY_TIERS),
        "years_of_experience": random.randint(1, 20),
        "is_verified": random.choice([True, False]),
        "languages_spoken": random.sample(LANGUAGES, k=random.randint(1, 3))
    }

def send_data(total_messages=1000, driver_prob=0.3, min_delay=0.005, max_delay=0.05, verbose=False):
    """Send simulated ride and driver data to Kafka topics"""
    print(f"\n Starting Enhanced Real-Time Simulation with {total_messages} events...")

    for i in tqdm(range(total_messages), desc="Sending Events", unit="msg"):
        if random.random() < driver_prob:
            driver = generate_driver()
            driver_binary = to_avro_binary(driver, driver_availability_avro_schema)
            drivers_producer.produce(DRIVER_TOPIC, value=driver_binary)
            if verbose:
                print(f" Sent Driver Update: {driver['driver_id']}")
        else:
            ride = generate_ride()
            ride_binary = to_avro_binary(ride, ride_request_avro_schema)
            rides_producer.produce(RIDE_TOPIC, value=ride_binary)
            if verbose:
                print(f" Sent Ride Request: {ride['user_id']}")

        rides_producer.poll(0)
        drivers_producer.poll(0)

        time.sleep(random.uniform(min_delay, max_delay))

    rides_producer.flush()
    drivers_producer.flush()
    print("\n Enhanced Simulation Completed Successfully!")

if __name__ == "__main__":
    send_data(
        total_messages=CONFIG["num_rides"],
        driver_prob=CONFIG["num_drivers"] / (CONFIG["num_rides"] + CONFIG["num_drivers"]),
        min_delay=0.005,
        max_delay=0.05,
        verbose=False
    )