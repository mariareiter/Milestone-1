# -*- coding: utf-8 -*-
"""FINAL_SIMULATION.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/17vtqC02ig90j7FycvwU_wE5Sq4wYjl6t
"""

# prompt: pip install fastavro

!pip install fastavro
!pip install confluent-kafka
!pip install faker

from confluent_kafka import Producer
import random
import fastavro
import io
from datetime import datetime, timedelta
from faker import Faker
import time
from tqdm import tqdm

# Setup
fake = Faker()

# Azure Event Hub connection config
EVENT_HUB_NAMESPACE = "iesstsabbadbaa-grp-01-05.servicebus.windows.net:9093"
RIDE_TOPIC = "ride_requests_group5"
DRIVER_TOPIC = "driver_availability_group5"

rides_producer_config = {
    "bootstrap.servers": EVENT_HUB_NAMESPACE,
    "security.protocol": "SASL_SSL",
    "sasl.mechanisms": "PLAIN",
    "sasl.username": "$ConnectionString",
    "sasl.password": (
        "Endpoint=sb://iesstsabbadbaa-grp-01-05.servicebus.windows.net/;"
        "SharedAccessKeyName=rideproducer;"
        "SharedAccessKey=7+4lt5nK7tXY3rIE14VB7l7jlPKXL9UaC+AEhCXmpNM=;"
        "EntityPath=ride_requests_group5"
    )
}

rides_producer = Producer(rides_producer_config)

drivers_producer_config = {
    "bootstrap.servers": EVENT_HUB_NAMESPACE,
    "security.protocol": "SASL_SSL",
    "sasl.mechanisms": "PLAIN",
    "sasl.username": "$ConnectionString",
    "sasl.password": (
        "Endpoint=sb://iesstsabbadbaa-grp-01-05.servicebus.windows.net/;"
        "SharedAccessKeyName=driverproducer;"
        "SharedAccessKey=Sh4m05EQ7ggASqZjMQ6vWBuoX7YNKmpMX+AEhJgoMFI=;"
        "EntityPath=driver_availability_group5"
    )
}

drivers_producer = Producer(drivers_producer_config)

# Enhanced configuration
CONFIG = {
    "num_rides": 15000,
    "num_drivers": 5000,
    "simulate_surge": True,
    "simulate_traffic": True,
    "inject_short_trips": True,
    "inject_fake_cancellations": True,
    "inject_surge_anomalies": True
}

# Extended NY Streets list
NY_STREETS = [
    # Manhattan Classics
    "5th Avenue", "Broadway", "Wall Street", "Madison Avenue", "Lexington Avenue",
    "Park Avenue", "Houston Street", "Delancey Street", "Canal Street", "Bowery",
    "West 42nd Street", "East 14th Street", "Christopher Street", "Varick Street", "Bleecker Street",
    "St. Mark's Place", "Seventh Avenue", "Ninth Avenue", "Amsterdam Avenue", "Columbus Avenue",
    # Brooklyn Legends
    "Flatbush Avenue", "Atlantic Avenue", "Bedford Avenue", "Fulton Street", "Eastern Parkway",
    "Court Street", "Kings Highway", "Ocean Parkway", "Dekalb Avenue", "Church Avenue",
    # Queens Reps
    "Queens Boulevard", "Jamaica Avenue", "Northern Boulevard", "Steinway Street", "Astoria Boulevard",
    "Roosevelt Avenue", "Liberty Avenue", "Rockaway Boulevard", "Hillside Avenue", "Main Street",
    # Bronx Flavor
    "Grand Concourse", "Fordham Road", "Jerome Avenue", "White Plains Road", "Tremont Avenue",
    "Arthur Avenue", "Webster Avenue", "Bronx River Parkway", "Sedgwick Avenue", "Kingsbridge Road",
    # Staten Island Love
    "Hylan Boulevard", "Richmond Avenue", "Victory Boulevard", "Bay Street", "Forest Avenue",
    # Bonus Flavor (NYC Icons & Spots)
    "Times Square", "Union Square", "Washington Square North", "Battery Place", "Tribeca West Street",
    "Chelsea Market Way", "Central Park West", "Lincoln Center Drive", "Metropolitan Avenue"
]

# Add to your constants section
LOCATION_COORDINATES = {
    # Manhattan
    "5th Avenue": (40.7750, -73.9654), "Broadway": (40.7590, -73.9845), "Wall Street": (40.7075, -74.0113),
    "Madison Avenue": (40.7637, -73.9720), "Lexington Avenue": (40.7570, -73.9705), "Park Avenue": (40.7517, -73.9763),
    "Houston Street": (40.7250, -73.9950), "Delancey Street": (40.7193, -73.9887), "Canal Street": (40.7181, -74.0006),
    "Bowery": (40.7203, -73.9939), "West 42nd Street": (40.7561, -73.9903), "East 14th Street": (40.7336, -73.9835),
    "Christopher Street": (40.7321, -74.0030), "Varick Street": (40.7272, -74.0064), "Bleecker Street": (40.7254, -73.9949),
    "St. Mark's Place": (40.7292, -73.9846), "Seventh Avenue": (40.7395, -74.0026), "Ninth Avenue": (40.7440, -74.0027),
    "Amsterdam Avenue": (40.7966, -73.9707), "Columbus Avenue": (40.7850, -73.9740),
    # Brooklyn
    "Flatbush Avenue": (40.6527, -73.9628), "Atlantic Avenue": (40.6832, -73.9765), "Bedford Avenue": (40.7081, -73.9571),
    "Fulton Street": (40.6885, -73.9802), "Eastern Parkway": (40.6700, -73.9511), "Court Street": (40.6914, -73.9918),
    "Kings Highway": (40.6057, -73.9609), "Ocean Parkway": (40.6126, -73.9656), "Dekalb Avenue": (40.6894, -73.9740),
    "Church Avenue": (40.6506, -73.9606),
    # Queens
    "Queens Boulevard": (40.7359, -73.8690), "Jamaica Avenue": (40.7027, -73.7896), "Northern Boulevard": (40.7618, -73.8970),
    "Steinway Street": (40.7580, -73.9189), "Astoria Boulevard": (40.7694, -73.9225), "Roosevelt Avenue": (40.7489, -73.8782),
    "Liberty Avenue": (40.6852, -73.8290), "Rockaway Boulevard": (40.6756, -73.8195), "Hillside Avenue": (40.7117, -73.7699),
    "Main Street": (40.7595, -73.8292),
    # Bronx
    "Grand Concourse": (40.8270, -73.9254), "Fordham Road": (40.8613, -73.8902), "Jerome Avenue": (40.8505, -73.9104),
    "White Plains Road": (40.8416, -73.8661), "Tremont Avenue": (40.8473, -73.8962), "Arthur Avenue": (40.8550, -73.8881),
    "Webster Avenue": (40.8620, -73.8964), "Bronx River Parkway": (40.8417, -73.8723), "Sedgwick Avenue": (40.8618, -73.9123),
    "Kingsbridge Road": (40.8675, -73.8978),
    # Staten Island
    "Hylan Boulevard": (40.5595, -74.1201), "Richmond Avenue": (40.5824, -74.1654), "Victory Boulevard": (40.6248, -74.1483),
    "Bay Street": (40.6383, -74.0756), "Forest Avenue": (40.6270, -74.1236),
    # NYC Icons
    "Times Square": (40.7580, -73.9855), "Union Square": (40.7359, -73.9911), "Washington Square North": (40.7313, -73.9970),
    "Battery Place": (40.7043, -74.0170), "Tribeca West Street": (40.7207, -74.0106), "Chelsea Market Way": (40.7423, -74.0060),
    "Central Park West": (40.7812, -73.9665), "Lincoln Center Drive": (40.7725, -73.9847), "Metropolitan Avenue": (40.7112, -73.9442)
}

# Utility function to retrieve lat/lng
def get_location_coordinates(location_name):
    return LOCATION_COORDINATES.get(location_name, (
        round(random.uniform(40.6000, 40.8800), 6),
        round(random.uniform(-74.0500, -73.8500), 6)
    ))

# Constants for simulation
PAYMENT_METHODS = ["credit_card", "cash", "mobile_payment", "voucher", "Paypal"]
WEATHER_CONDITIONS = ["sunny", "cloudy", "rainy", "snowy", "foggy"]
LOYALTY_TIERS = ["Bronze", "Silver", "Gold", "Platinum"]

# Car categories and brands
SERVICE_TYPES = ["Share", "Standard", "Green", "Comfort", "Black", "Van"]
SERVICE_TIME_MODES = ["Wait and Save", "Programmed Ride", "Just Ride"]

BLACK_CAR_BRANDS = ["Tesla", "Porsche", "Land Rover", "Mercedes-Benz", "BMW", "Audi", "Jaguar", "Cadillac"]
COMFORT_BRANDS = ["Volvo", "LEXUS", "Buick", "Acura", "Chrysler"]
GREEN_CAR_BRANDS = ["Tesla", "Nissan", "Hyundai", "Kia", "Toyota", "Chevrolet", "Volkswagen"]
STANDARD_CAR_BRANDS = ["Toyota", "Ford", "Honda", "Hyundai", "Chevrolet", "Kia", "Nissan", "Mazda", "Subaru", "Jeep"]
VAN_CAR_BRANDS = ["Mercedes-Benz", "Toyota", "Volkswagen", "Ford", "Chrysler", "Kia"]
SHARE_CAR_BRANDS = ["Fiat", "Mini", "Nissan", "Hyundai", "Chevrolet", "Ford", "Toyota"]
CATEGORY_TO_BRANDS = {
    "Black": BLACK_CAR_BRANDS,
    "Comfort": COMFORT_BRANDS,
    "Green": GREEN_CAR_BRANDS,
    "Standard": STANDARD_CAR_BRANDS,
    "Van": VAN_CAR_BRANDS,
    "Share": SHARE_CAR_BRANDS
}

CANCELLATION_REASONS = ["No driver available", "User cancelled", "Driver cancelled", "Pricing issue", "Long waiting time"]
PROMO_CODES = ["SAVE10", "RIDEFREE", None, None, None, None]  # More likely to have no promo code
LANGUAGES = ["English", "Spanish", "French", "Mandarin", "Arabic", "Russian", "Italian", "Japanese"]

# Updated Avro schemas with expanded fields

# Update the ride request schema
ride_request_avro_schema = {
    "type": "record",
    "name": "RideRequest",
    "fields": [
        {"name": "user_id", "type": "string"},
        {"name": "user_name", "type": "string"},
        {"name": "pickup_location", "type": "string"},
        {"name": "pickup_lat", "type": "double"},
        {"name": "pickup_lng", "type": "double"},
        {"name": "destination", "type": "string"},
        {"name": "destination_lat", "type": "double"},
        {"name": "destination_lng", "type": "double"},
        {"name": "timestamp", "type": "string"},
        {"name": "pickup_time", "type": ["null", "string"], "default": None},
        {"name": "dropoff_time", "type": ["null", "string"], "default": None},
        {"name": "status", "type": {"type": "enum", "name": "Status", "symbols": ["requested", "cancelled", "accepted", "ongoing", "completed"]}},
        {"name": "price", "type": ["null", "double"], "default": 0.0},
        {"name": "surge", "type": "boolean"},
        {"name": "traffic", "type": "string"},
        {"name": "payment_mode", "type": "string"},
        {"name": "weather", "type": "string"},
        {"name": "vehicle_type", "type": ["null", "string"], "default": None},
        {"name": "vehicle_brand", "type": ["null", "string"], "default": None},
        {"name": "driver_id", "type": ["null", "string"], "default": None},
        {"name": "distance_km", "type": ["null", "double"], "default": 0.0},
        {"name": "estimated_duration_min", "type": ["null", "double"], "default": 0.0},
        {"name": "cancellation_reason", "type": ["null", "string"], "default": None},
        {"name": "promo_code", "type": ["null", "string"], "default": None},
        {"name": "is_premium_user", "type": "boolean"},
        {"name": "estimated_driver_arrival_min", "type": ["null", "double"], "default": 0.0},
        {"name": "car_category", "type": "string"},
        {"name": "time_programmed", "type": ["null", "string"], "default": None},
        {"name": "time_of_service", "type": "string"},
        {"name": "final_price", "type": ["null", "double"], "default": 0.0}
    ]
}

# Update the driver availability schema
driver_availability_avro_schema = {
    "type": "record",
    "name": "DriverAvailability",
    "fields": [
        {"name": "driver_id", "type": "string"},
        {"name": "driver_name", "type": "string"},
        {"name": "location", "type": "string"},
        {"name": "latitude", "type": "double"},
        {"name": "longitude", "type": "double"},
        {"name": "status", "type": {"type": "enum", "name": "DriverStatus", "symbols": ["available", "busy"]}},
        {"name": "timestamp", "type": "string"},
        {"name": "license_plate", "type": "string"},
        {"name": "vehicle_type", "type": "string"},
        {"name": "vehicle_brand", "type": "string"},
        {"name": "rating", "type": "double"},
        {"name": "loyalty_tier", "type": "string"},
        {"name": "years_of_experience", "type": "int"},
        {"name": "is_verified", "type": "boolean"},
        {"name": "languages_spoken", "type": {"type": "array", "items": "string"}}
    ]
}


# Enhanced utility functions
def generate_time_based_timestamp():
    """Generate realistic timestamp based on time-of-day blocks"""
    time_blocks = [
        (7, 9),    # morning rush
        (12, 14),  # lunch
        (17, 19),  # evening rush
        (0, 2)     # late night
    ]
    hour_range = random.choice(time_blocks)
    hour = random.randint(*hour_range)
    dt = datetime.utcnow().replace(hour=hour, minute=random.randint(0, 59), second=0, microsecond=0)
    return dt.isoformat()

def get_surge_price(base_price, location, timestamp):
    """Simulate surge pricing based on time and location with optional anomalies"""
    hour = int(timestamp[11:13])
    is_peak = 7 <= hour <= 9 or 17 <= hour <= 20
    is_hot_zone = any(keyword in location for keyword in ["Avenue", "Broadway", "Boulevard", "Park", "Times Square"])
    should_surge = is_peak and is_hot_zone and random.random() < 0.7

    # Inject anomalous surge pricing occasionally
    if CONFIG["inject_surge_anomalies"] and random.random() < 0.02:
        # Either extremely high surge or surge at unusual time/place
        if random.random() < 0.5:
            # Extremely high surge
            return round(base_price * random.uniform(2.5, 4.0), 2), True
        else:
            # Surge at unusual time/place (off-peak or unpopular area)
            if not should_surge:
                return round(base_price * random.uniform(1.5, 2.0), 2), True

    if CONFIG["simulate_surge"] and should_surge:
        return round(base_price * random.uniform(1.5, 2.0), 2), True

    return base_price, False

def get_traffic_condition(location, timestamp):
    """Simulate traffic condition based on location and time"""
    hour = int(timestamp[11:13])
    if CONFIG["simulate_traffic"] and (location in NY_STREETS) and (hour in list(range(7, 10)) + list(range(17, 20))):
        return random.choice(["heavy", "moderate"])
    return "light"

def generate_license_plate():
    """Generate a realistic license plate"""
    return f"{''.join(random.choices('ABCDEFGHIJKLMNOPQRSTUVWXYZ', k=3))}-{''.join(random.choices('0123456789', k=4))}"

def to_avro_binary(record, schema):
    """Serialize record to Avro binary format"""
    buffer = io.BytesIO()
    fastavro.schemaless_writer(buffer, schema, record)
    return buffer.getvalue()

# Enhanced simulation functions
def generate_ride():
    """Generate a realistic ride request with enhanced details including geographic coordinates"""
    # Determine ride status
    # Add increased cancellation probability if configured
    if CONFIG["inject_fake_cancellations"] and random.random() < 0.15:
        status = "cancelled"
    else:
        status = random.choice(["requested", "cancelled", "accepted", "ongoing", "completed"])

    # Generate base timestamp and location
    ts = generate_time_based_timestamp()
    pickup = random.choice(NY_STREETS)
    destination = random.choice([s for s in NY_STREETS if s != pickup])

    # Get geographic coordinates
    pickup_lat, pickup_lng = get_location_coordinates(pickup)
    destination_lat, destination_lng = get_location_coordinates(destination)

    # Setup service type and time mode
    car_category = random.choice(SERVICE_TYPES)
    time_of_service = random.choices(
        SERVICE_TIME_MODES,
        weights=[0.3, 0.05, 0.65]  # 30% Wait and Save, 10% Programmed Ride, 60% Just Ride
    )[0]


    # Select vehicle brand based on category
    vehicle_brand = random.choice(CATEGORY_TO_BRANDS.get(car_category, STANDARD_CAR_BRANDS))

    # Calculate trip distance - with option for short trips if configured
    if CONFIG["inject_short_trips"] and random.random() < 0.2:
        distance_km = round(random.uniform(0.5, 2.5), 2)  # Very short trips
    else:
        distance_km = round(random.uniform(1.0, 20.0), 2)

    # Traffic condition
    traffic = get_traffic_condition(pickup, ts)

    # Pricing logic
    # Base fare calculations with modifiers
    base_rate_per_km = 2.0
    traffic_multiplier = {"light": 1.0, "moderate": 1.2, "heavy": 1.5}
    time_of_service_multiplier = {"Wait and Save": 0.85, "Just Ride": 1.0, "Programmed Ride": 1.15}
    service_price_multiplier = {"Share": 0.8, "Standard": 1.0, "Green": 1.1, "Comfort": 1.25, "Black": 1.5, "Van": 1.3}

    # Calculate base price
    base_price = round(
        distance_km * base_rate_per_km *
        traffic_multiplier.get(traffic, 1.0) *
        service_price_multiplier.get(car_category, 1.0) *
        time_of_service_multiplier.get(time_of_service, 1.0),
        2
    )


    # Time-related fields
    pickup_time = None
    dropoff_time = None
    time_programmed = None
    estimated_driver_arrival_min = None

    # Handle timing for different statuses
    if status in ["accepted", "ongoing", "completed"]:
        pickup_dt = datetime.fromisoformat(ts) + timedelta(minutes=random.randint(2, 10))
        estimated_driver_arrival_min = round((pickup_dt - datetime.fromisoformat(ts)).total_seconds() / 60, 1)

        # Determine waiting time based on time_of_service
        if time_of_service == "Wait and Save":
            wait_minutes = random.randint(10, 20)
        elif time_of_service == "Just Ride":
            wait_minutes = random.randint(2, 6)
        elif time_of_service == "Programmed Ride":
            wait_minutes = random.randint(60, 1440)  # 1 to 24 hours in minutes
        else:
            wait_minutes = random.randint(2, 10)  # fallback

        pickup_dt = datetime.fromisoformat(ts) + timedelta(minutes=wait_minutes)
        estimated_driver_arrival_min = wait_minutes

        if time_of_service == "Programmed Ride":
            pickup_time = pickup_dt.isoformat()
            time_programmed = pickup_time
        else:
            pickup_time = pickup_dt.isoformat()


        # Calculate dropoff time based on distance and traffic
        minutes_per_km = {
            "light": 2.0,
            "moderate": 3.0,
            "heavy": 4.5
        }
        trip_minutes = max(5, round(distance_km * minutes_per_km.get(traffic, 2.5)))
        dropoff_dt = pickup_dt + timedelta(minutes=trip_minutes)
        dropoff_time = dropoff_dt.isoformat()

    elif time_of_service == "Programmed Ride":
        # Handle programmed rides even if not yet accepted
        time_programmed = (datetime.fromisoformat(ts) + timedelta(hours=random.randint(1, 24))).isoformat()

    # Apply surge pricing
    price, surge = get_surge_price(base_price, pickup, ts)

    # Apply "Wait and Save" discount first
    if time_of_service == "Wait and Save":
        wait_discount = round(price * 0.05, 2)
    else:
        wait_discount = 0.0

    price_after_wait_discount = round(price - wait_discount, 2)

    # Apply promo code on top of "Wait and Save"
    promo_code = random.choice(PROMO_CODES)
    if promo_code == "SAVE10":
        promo_discount = round(price_after_wait_discount * 0.10, 2)
    elif promo_code == "RIDEFREE":
        promo_discount = round(price_after_wait_discount * 0.25, 2)
    else:
        promo_discount = 0.0

    final_price = round(price_after_wait_discount - promo_discount, 2)

    return {
        "user_id": str(fake.uuid4()),
        "user_name": fake.name(),
        "pickup_location": pickup,
        "pickup_lat": pickup_lat,
        "pickup_lng": pickup_lng,
        "destination": destination,
        "destination_lat": destination_lat,
        "destination_lng": destination_lng,
        "timestamp": ts,
        "pickup_time": pickup_time,
        "dropoff_time": dropoff_time,
        "status": status,
        "price": price,
        "surge": surge,
        "traffic": traffic,
        "payment_mode": random.choice(PAYMENT_METHODS),
        "weather": random.choice(WEATHER_CONDITIONS),
        "vehicle_type": car_category,
        "vehicle_brand": vehicle_brand,
        "driver_id": str(fake.uuid4()) if status != "requested" else None,
        "distance_km": distance_km,
        "estimated_duration_min": (
            round((datetime.fromisoformat(dropoff_time) - datetime.fromisoformat(pickup_time)).total_seconds() / 60, 1)
            if pickup_time and dropoff_time else None
        ),
        "cancellation_reason": random.choice(CANCELLATION_REASONS) if status == "cancelled" else None,
        "promo_code": promo_code,
        "is_premium_user": random.choice([True, False]),
        "estimated_driver_arrival_min": estimated_driver_arrival_min,
        "car_category": car_category,
        "time_programmed": time_programmed,
        "time_of_service": time_of_service,
        "final_price": final_price
    }

def generate_driver():
    vehicle_category = random.choice(SERVICE_TYPES)
    vehicle_brand = random.choice(CATEGORY_TO_BRANDS.get(vehicle_category, STANDARD_CAR_BRANDS))

    location = random.choice(NY_STREETS)
    latitude, longitude = get_location_coordinates(location)

    return {
        "driver_id": str(fake.uuid4()),
        "driver_name": fake.name(),
        "location": location,
        "latitude": latitude,
        "longitude": longitude,
        "status": random.choice(["available", "busy"]),
        "timestamp": datetime.utcnow().isoformat(),
        "license_plate": generate_license_plate(),
        "vehicle_type": vehicle_category,
        "vehicle_brand": vehicle_brand,
        "rating": round(random.uniform(3.0, 5.0), 2),
        "loyalty_tier": random.choice(LOYALTY_TIERS),
        "years_of_experience": random.randint(1, 20),
        "is_verified": random.choice([True, False]),
        "languages_spoken": random.sample(LANGUAGES, k=random.randint(1, 3))
    }

def send_data(total_messages=1000, driver_prob=0.3, min_delay=0.005, max_delay=0.05, verbose=False):
    """Send simulated ride and driver data to Kafka topics"""
    print(f"\n Starting Enhanced Real-Time Simulation with {total_messages} events...")

    for i in tqdm(range(total_messages), desc="Sending Events", unit="msg"):
        if random.random() < driver_prob:
            driver = generate_driver()
            driver_binary = to_avro_binary(driver, driver_availability_avro_schema)
            drivers_producer.produce(DRIVER_TOPIC, value=driver_binary)
            if verbose:
                print(f" Sent Driver Update: {driver['driver_id']}")
        else:
            ride = generate_ride()
            ride_binary = to_avro_binary(ride, ride_request_avro_schema)
            rides_producer.produce(RIDE_TOPIC, value=ride_binary)
            if verbose:
                print(f" Sent Ride Request: {ride['user_id']}")

        rides_producer.poll(0)
        drivers_producer.poll(0)

        time.sleep(random.uniform(min_delay, max_delay))

    rides_producer.flush()
    drivers_producer.flush()
    print("\n Enhanced Simulation Completed Successfully!")

if __name__ == "__main__":
    send_data(
        total_messages=CONFIG["num_rides"],
        driver_prob=CONFIG["num_drivers"] / (CONFIG["num_rides"] + CONFIG["num_drivers"]),
        min_delay=0.005,
        max_delay=0.05,
        verbose=False
    )